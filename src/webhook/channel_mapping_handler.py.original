# -*- coding: utf-8 -*-

"""
Manipulador de eventos de mapeamento de canais.
Este módulo contém funções para processar eventos de mapeamento de canais
enviados pelo módulo ai_credentials_manager.
"""

import os
import yaml
import json
import logging
from datetime import datetime
from typing import Dict, Any, Optional

logger = logging.getLogger(__name__)

def process_mapping_event(webhook_data: Dict[str, Any], credential_encryption=None) -> Dict[str, Any]:
    """
    Processa um evento de sincronização de mapeamento de canal.

    Args:
        webhook_data: Dados do webhook
        credential_encryption: Objeto para criptografia de credenciais

    Returns:
        Resultado do processamento
    """
    try:
        logger.info("Processando evento de sincronização de mapeamento de canal")

        # Extrair informações do evento
        account_id = webhook_data.get("account_id")
        token = webhook_data.get("token")
        mapping = webhook_data.get("mapping", {})

        # Validar dados obrigatórios
        if not account_id or not mapping:
            logger.warning("Evento de mapeamento sem account_id ou mapping")
            return {"success": False, "error": "Dados incompletos: account_id e mapping são obrigatórios"}

        # Verificar token de autenticação
        if not token:
            logger.warning("Evento de mapeamento sem token de autenticação")
            return {"success": False, "error": "Token de autenticação não fornecido"}

        logger.info(f"Processando mapeamento para account_id: {account_id}")

        # Verificar se o diretório config existe
        config_dir = os.path.join(os.getcwd(), "config")
        if not os.path.exists(config_dir):
            os.makedirs(config_dir, exist_ok=True)

        # Caminho para o arquivo de mapeamento
        mapping_path = os.path.join(config_dir, "chatwoot_mapping.yaml")

        # Carregar mapeamento existente ou criar novo
        if os.path.exists(mapping_path):
            with open(mapping_path, 'r') as f:
                mapping_data = yaml.safe_load(f) or {}
        else:
            mapping_data = {
                "accounts": {},
                "inboxes": {},
                "fallbacks": [],
                "special_numbers": []
            }

        # Garantir que todas as seções existam
        if "accounts" not in mapping_data:
            mapping_data["accounts"] = {}
        if "inboxes" not in mapping_data:
            mapping_data["inboxes"] = {}
        if "fallbacks" not in mapping_data:
            mapping_data["fallbacks"] = []
        if "special_numbers" not in mapping_data:
            mapping_data["special_numbers"] = []

        # Extrair dados do mapeamento
        chatwoot_account_id = mapping.get("chatwoot_account_id")
        chatwoot_inbox_id = mapping.get("chatwoot_inbox_id")
        internal_account_id = mapping.get("internal_account_id")
        domain = mapping.get("domain")
        is_fallback = mapping.get("is_fallback", False)
        sequence = mapping.get("sequence", 10)
        special_whatsapp_numbers = mapping.get("special_whatsapp_numbers", [])

        # Validar dados obrigatórios do mapeamento
        if not chatwoot_account_id or not internal_account_id or not domain:
            logger.warning("Mapeamento sem chatwoot_account_id, internal_account_id ou domain")
            return {"success": False, "error": "Dados incompletos: chatwoot_account_id, internal_account_id e domain são obrigatórios"}

        # Atualizar mapeamento de accounts
        mapping_data["accounts"][str(chatwoot_account_id)] = {
            "domain": domain,
            "account_id": internal_account_id
        }

        # Atualizar mapeamento de inboxes se especificado
        if chatwoot_inbox_id:
            mapping_data["inboxes"][str(chatwoot_inbox_id)] = {
                "domain": domain,
                "account_id": internal_account_id
            }

        # Atualizar fallbacks
        if is_fallback:
            # Remover fallback existente para este account_id (se houver)
            mapping_data["fallbacks"] = [f for f in mapping_data["fallbacks"]
                                        if f.get("account_id") != internal_account_id]

            # Adicionar novo fallback
            mapping_data["fallbacks"].append({
                "domain": domain,
                "account_id": internal_account_id,
                "sequence": sequence
            })

            # Ordenar fallbacks por sequência
            mapping_data["fallbacks"].sort(key=lambda x: x.get("sequence", 10))
        else:
            # Remover fallback para este account_id (se existir)
            mapping_data["fallbacks"] = [f for f in mapping_data["fallbacks"]
                                        if f.get("account_id") != internal_account_id]

        # Atualizar números especiais de WhatsApp
        # Primeiro, remover números existentes para este account_id
        mapping_data["special_numbers"] = [n for n in mapping_data["special_numbers"]
                                          if n.get("account_id") != internal_account_id]

        # Adicionar novos números especiais
        for number_data in special_whatsapp_numbers:
            number = number_data.get("number")
            crew = number_data.get("crew", "analytics")

            if number:
                mapping_data["special_numbers"].append({
                    "number": number,
                    "crew": crew,
                    "domain": domain,
                    "account_id": internal_account_id
                })

        # Salvar mapeamento atualizado
        try:
            # Primeiro, converter para string
            yaml_content = yaml.dump(mapping_data, default_flow_style=False, allow_unicode=True)

            # Salvar usando 'w' e especificando a codificação
            with open(mapping_path, 'w', encoding='utf-8') as f:
                f.write(yaml_content)

            logger.info(f"Arquivo salvo com sucesso usando método alternativo: {len(yaml_content)} bytes")

            # Criar uma cópia do arquivo para garantir que ele seja legível
            backup_path = f"{mapping_path}.bak"
            with open(backup_path, 'w', encoding='utf-8') as f:
                yaml.dump(mapping_data, f, default_flow_style=False, allow_unicode=True)
            logger.info(f"Backup do arquivo criado em: {backup_path}")
        except Exception as e:
            logger.error(f"Erro ao salvar arquivo YAML: {str(e)}")
            # Tentar método alternativo
            with open(mapping_path, 'w', encoding='utf-8') as f:
                yaml.dump(mapping_data, f, default_flow_style=False, allow_unicode=True)
            logger.info("Arquivo salvo usando método padrão após falha no método alternativo")

        logger.info(f"Mapeamento YAML atualizado em {mapping_path}")

        return {
            "success": True,
            "message": "Mapeamento sincronizado com sucesso",
            "account_id": account_id,
            "mapping_path": mapping_path
        }

    except Exception as e:
        logger.error(f"Erro ao processar evento de mapeamento: {str(e)}")
        import traceback
        traceback.print_exc()
        return {
            "success": False,
            "error": str(e)
        }
