# CrewAI Multi-Tenant - Plano de ImplementaÃ§Ã£o

Este documento descreve o plano de implementaÃ§Ã£o para a nova arquitetura da CrewAI Multi-Tenant, otimizada para baixa latÃªncia, isolamento entre tenants e escalabilidade.

## 1. VisÃ£o Geral da Nova Arquitetura

### 1.1 PrincÃ­pios Fundamentais

- **Uma Ãºnica crew para todos os tenants** (substituindo mÃºltiplas crews por tenant)
- **Account_ID como chave central** para isolamento de dados e configuraÃ§Ãµes
- **ConfiguraÃ§Ãµes via YAML** para informaÃ§Ãµes estÃ¡ticas (substituindo o company_metadata_agent)
- **Acesso direto a dados nas crews** (substituindo o data_proxy_agent centralizado)
- **Processamento paralelo** para reduzir latÃªncia
- **Cache em mÃºltiplas camadas** para otimizar desempenho

### 1.2 Fluxo de Processamento

```
Cliente envia pergunta (via Chatwoot ou App)
  |
FastAPI recebe (com account_id)
  |
ConfigLoader busca o YAML (Redis ou local)
  |
Verifica horÃ¡rio de atendimento
  |
Inicia a Crew com:
  ðŸ”¹ Agente de IntenÃ§Ã£o â†’ detecta a intenÃ§Ã£o do cliente
     â”œâ”€ Regras? â†’ agente vetorial (rules)
     â”œâ”€ Suporte? â†’ agente vetorial (support_documents)
     â”œâ”€ Institucional? â†’ informaÃ§Ãµes do YAML
     â”œâ”€ AÃ§Ã£o no Odoo? â†’ MCP Agent com tools REST
     â”œâ”€ Falar com humano? â†’ sinaliza handoff
  |
Finalizador junta tudo, formata com saudaÃ§Ã£o e assina
```

## 2. Estrutura do Projeto

### 2.1 OrganizaÃ§Ã£o de DiretÃ³rios

```
crewai-multi-tenant/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â””â”€â”€ main.py                 # Entrada FastAPI
â”‚   â”œâ”€â”€ agents/
â”‚   â”‚   â”œâ”€â”€ intention_agent.py      # ClassificaÃ§Ã£o
â”‚   â”‚   â”œâ”€â”€ vector_agents.py        # Agentes de busca vetorial
â”‚   â”‚   â”œâ”€â”€ mcp_agent.py            # IntegraÃ§Ã£o com Odoo
â”‚   â”‚   â””â”€â”€ response_agent.py       # Finalizador
â”‚   â”œâ”€â”€ crew/
â”‚   â”‚   â”œâ”€â”€ crew_factory.py         # Montagem completa
â”‚   â”‚   â”œâ”€â”€ config_loader.py        # Redis + YAML + Odoo
â”‚   â”‚   â”œâ”€â”€ memory.py               # MemÃ³ria por tenant
â”‚   â”‚   â””â”€â”€ handoff_detector.py     # Detecta se deve redirecionar para humano
â”‚   â”œâ”€â”€ tools/
â”‚   â”‚   â”œâ”€â”€ vector_tools.py         # ConexÃµes Qdrant
â”‚   â”‚   â””â”€â”€ mcp_tools.py            # Tools REST Odoo
â”‚   â””â”€â”€ utils/
â”‚       â””â”€â”€ horario.py              # Verifica horÃ¡rios de atendimento
â”œâ”€â”€ config/
â”‚   â””â”€â”€ domains/
â”‚       â””â”€â”€ retail/
â”‚           â””â”€â”€ account_1/
â”‚               â””â”€â”€ config.yaml     # ConfiguraÃ§Ã£o especÃ­fica do tenant
â”œâ”€â”€ requirements.txt                # DependÃªncias
â”œâ”€â”€ .env.example                    # OpenAI Key, Redis, etc.
â””â”€â”€ README.md                       # InstruÃ§Ãµes de uso
```

### 2.2 DependÃªncias

```
crewai[tools]
langchain
langchain-openai
langchain-community
fastapi
uvicorn
qdrant-client
redis
python-dotenv
requests
PyYAML
```

## 3. Componentes Principais

### 3.1 ConfiguraÃ§Ã£o YAML

O arquivo de configuraÃ§Ã£o YAML substituirÃ¡ o company_metadata_agent, contendo informaÃ§Ãµes estÃ¡ticas como:

```yaml
# config/domains/retail/account_1/config.yaml
account_id: "account_1"
name: "Loja Exemplo"
domain: "retail"

# ConfiguraÃ§Ãµes de atendimento
atendimento:
  horarios:
    dias: ["segunda", "terÃ§a", "quarta", "quinta", "sexta"]
    horario: "09:00 - 18:00"
    fuso: "America/Sao_Paulo"
  regras:
    atender_fora_do_horario: false

# ConfiguraÃ§Ãµes de estilo
estilo:
  tone: "formal"  # formal ou informal
  use_emoji: false
  saudacao: "OlÃ¡! Bem-vindo Ã  Loja Exemplo."
  assinatura: "Atenciosamente, Equipe de Atendimento"

# InformaÃ§Ãµes institucionais
institucional:
  endereco: "Rua Exemplo, 123 - Centro"
  telefone: "(11) 1234-5678"
  email: "contato@exemplo.com"
  sobre: "A Loja Exemplo Ã© especializada em produtos de alta qualidade desde 2010."

# IntegraÃ§Ãµes
integracoes:
  mcp:
    url: "http://localhost:9000"
    timeout: 3
  qdrant:
    collections:
      - "business_rules"
      - "support_documents"
```

### 3.2 Agentes Especializados

#### 3.2.1 Agente de IntenÃ§Ã£o

```python
from crewai import Agent

def build_intention_agent(config):
    return Agent(
        role="Classificador de IntenÃ§Ã£o",
        goal="Detectar a intenÃ§Ã£o do cliente e direcionar para o agente apropriado",
        backstory="VocÃª analisa mensagens e identifica precisamente o que o cliente deseja.",
        verbose=True
    )
```

#### 3.2.2 Agentes Vetoriais

```python
from crewai import Agent
from app.tools.vector_tools import get_vector_tool

def build_rules_agent(account_id):
    return Agent(
        role="Especialista em Regras de NegÃ³cio",
        goal="Encontrar regras de negÃ³cio relevantes para a consulta do cliente",
        backstory="VocÃª conhece todas as polÃ­ticas, promoÃ§Ãµes e regras da empresa.",
        tools=[get_vector_tool("business_rules", account_id)],
        verbose=True
    )

def build_support_agent(account_id):
    return Agent(
        role="Especialista em Suporte",
        goal="Encontrar informaÃ§Ãµes de suporte relevantes para a consulta do cliente",
        backstory="VocÃª Ã© especializado em resolver problemas tÃ©cnicos e dÃºvidas sobre produtos.",
        tools=[get_vector_tool("support_documents", account_id)],
        verbose=True
    )
```

#### 3.2.3 Agente MCP

```python
from crewai import Agent
from app.tools.mcp_tools import get_mcp_tools

def build_mcp_agent(account_id, config):
    mcp_url = config["integracoes"]["mcp"]["url"]
    return Agent(
        role="Agente de IntegraÃ§Ã£o com Odoo",
        goal="Executar aÃ§Ãµes no sistema Odoo conforme solicitado pelo cliente",
        backstory="VocÃª tem acesso ao sistema Odoo e pode realizar consultas e operaÃ§Ãµes.",
        tools=get_mcp_tools(account_id, mcp_url),
        verbose=True
    )
```

#### 3.2.4 Agente de Resposta

```python
from crewai import Agent

def build_response_agent(config):
    estilo = config["estilo"]
    tone = "informal" if estilo.get("tone") == "informal" else "formal"
    emojis = "Use emojis ocasionalmente. ðŸ˜Š" if estilo.get("use_emoji") else "NÃ£o use emojis."

    return Agent(
        role="Finalizador de Atendimento",
        goal="Formular uma resposta final clara, cordial e personalizada para o cliente",
        backstory=f"VocÃª Ã© um especialista em atendimento ao cliente com tom {tone}. "
                 f"VocÃª sempre inicia com '{estilo['saudacao']}' e finaliza com '{estilo['assinatura']}'. {emojis}",
        verbose=True
    )
```

### 3.3 Ferramentas Especializadas

#### 3.3.1 Ferramentas Vetoriais

```python
from langchain.vectorstores import Qdrant
from langchain_openai import OpenAIEmbeddings
from qdrant_client import QdrantClient
from crewai_tools import VectorStoreTool

embedding_model = OpenAIEmbeddings(model="text-embedding-3-small")
qdrant_client = QdrantClient(host="localhost", port=6333)

def get_vector_tool(collection_name, account_id):
    descriptions = {
        "business_rules": "Busca regras de negÃ³cio, polÃ­ticas e promoÃ§Ãµes da empresa",
        "support_documents": "Busca documentos de suporte, manuais e FAQs"
    }

    return VectorStoreTool(
        name=f"{collection_name.capitalize()} Tool",
        description=descriptions.get(collection_name, f"Busca em {collection_name}"),
        vectorstore=Qdrant(
            client=qdrant_client,
            collection_name=collection_name,
            embeddings=embedding_model,
            metadata_filter={"account_id": account_id}
        ),
        top_k=3
    )
```

#### 3.3.2 Ferramentas MCP

```python
from crewai_tools import BaseTool
import requests

class MCPTool(BaseTool):
    def __init__(self, name, description, endpoint, mcp_url, account_id, method="GET"):
        self.endpoint = endpoint
        self.mcp_url = mcp_url
        self.account_id = account_id
        self.method = method
        super().__init__(name=name, description=description)

    def _run(self, **kwargs):
        url = f"{self.mcp_url}/{self.endpoint}"
        headers = {"X-Account-ID": self.account_id}

        try:
            if self.method == "GET":
                response = requests.get(url, params=kwargs, headers=headers, timeout=3)
            else:
                response = requests.post(url, json=kwargs, headers=headers, timeout=3)

            return response.json()
        except Exception as e:
            return f"Erro ao acessar o MCP: {str(e)}"

def get_mcp_tools(account_id, mcp_url):
    return [
        MCPTool(
            name="ConsultaProduto",
            description="Consulta informaÃ§Ãµes sobre um produto no Odoo",
            endpoint="produto/info",
            mcp_url=mcp_url,
            account_id=account_id
        ),
        MCPTool(
            name="ConsultaEstoque",
            description="Verifica a disponibilidade de um produto em estoque",
            endpoint="produto/estoque",
            mcp_url=mcp_url,
            account_id=account_id
        ),
        MCPTool(
            name="CriarPedido",
            description="Cria um novo pedido de venda no Odoo",
            endpoint="venda/criar",
            mcp_url=mcp_url,
            account_id=account_id,
            method="POST"
        )
    ]
```

### 3.4 MemÃ³ria Redis Multi-Tenant

```python
from langchain.memory.chat_message_histories import RedisChatMessageHistory
from langchain.memory import ConversationBufferMemory

def get_memory(account_id):
    history = RedisChatMessageHistory(
        session_id=f"chat:{account_id}",
        url="redis://localhost:6379"
    )
    return ConversationBufferMemory(
        chat_memory=history,
        return_messages=True,
        memory_key="chat_history"
    )
```

### 3.5 Carregador de ConfiguraÃ§Ã£o

```python
import os
import yaml
import json
import redis
import requests
from typing import Dict, Any

redis_client = redis.Redis(host='localhost', port=6379, decode_responses=True)

def get_tenant_config(account_id: str) -> Dict[str, Any]:
    """
    Carrega a configuraÃ§Ã£o do tenant com cache Redis.

    Args:
        account_id: ID da conta do tenant

    Returns:
        ConfiguraÃ§Ã£o do tenant
    """
    # Verificar cache Redis
    cache_key = f"config:{account_id}"
    cached_config = redis_client.get(cache_key)

    if cached_config:
        return json.loads(cached_config)

    # Tentar carregar do arquivo YAML
    yaml_path = f"config/domains/retail/{account_id}/config.yaml"

    if os.path.exists(yaml_path):
        with open(yaml_path, 'r', encoding='utf-8') as file:
            config = yaml.safe_load(file)

            # Armazenar em cache
            redis_client.set(cache_key, json.dumps(config), ex=600)  # TTL: 10 minutos

            return config

    # Tentar obter do Odoo via API
    try:
        response = requests.get(
            f"http://localhost:8001/api/v1/config/{account_id}",
            timeout=3
        )

        if response.ok:
            config = response.json()

            # Armazenar em cache
            redis_client.set(cache_key, json.dumps(config), ex=600)

            # Salvar localmente para fallback
            os.makedirs(os.path.dirname(yaml_path), exist_ok=True)
            with open(yaml_path, 'w', encoding='utf-8') as file:
                yaml.dump(config, file)

            return config
    except Exception as e:
        print(f"Erro ao obter configuraÃ§Ã£o do Odoo: {e}")

    # ConfiguraÃ§Ã£o padrÃ£o como fallback
    return {
        "account_id": account_id,
        "name": "Loja PadrÃ£o",
        "domain": "retail",
        "atendimento": {
            "horarios": {
                "dias": ["segunda", "terÃ§a", "quarta", "quinta", "sexta"],
                "horario": "09:00 - 18:00",
                "fuso": "America/Sao_Paulo"
            },
            "regras": {
                "atender_fora_do_horario": False
            }
        },
        "estilo": {
            "tone": "formal",
            "use_emoji": False,
            "saudacao": "OlÃ¡!",
            "assinatura": "Atenciosamente, Equipe de Atendimento"
        }
    }
```

### 3.6 Verificador de HorÃ¡rio

```python
from datetime import datetime
import pytz

def esta_dentro_do_horario(config):
    """
    Verifica se o momento atual estÃ¡ dentro do horÃ¡rio de atendimento.

    Args:
        config: ConfiguraÃ§Ã£o do tenant

    Returns:
        True se estiver dentro do horÃ¡rio, False caso contrÃ¡rio
    """
    horarios = config["atendimento"]["horarios"]

    # Obter fuso horÃ¡rio
    tz_name = horarios.get("fuso", "America/Sao_Paulo")
    tz = pytz.timezone(tz_name)

    # Obter data e hora atual
    agora = datetime.now(tz)
    dia_semana = agora.strftime("%A").lower()
    hora_atual = agora.strftime("%H:%M")

    # Mapear dias da semana em portuguÃªs
    mapeamento_dias = {
        "monday": "segunda",
        "tuesday": "terÃ§a",
        "wednesday": "quarta",
        "thursday": "quinta",
        "friday": "sexta",
        "saturday": "sÃ¡bado",
        "sunday": "domingo"
    }

    dia_pt = mapeamento_dias.get(dia_semana, dia_semana)

    # Verificar se o dia atual estÃ¡ na lista de dias de atendimento
    if dia_pt not in horarios["dias"]:
        return False

    # Verificar se a hora atual estÃ¡ dentro do horÃ¡rio de atendimento
    inicio, fim = horarios["horario"].split(" - ")

    return inicio <= hora_atual <= fim
```

### 3.7 FÃ¡brica de Crew

```python
from crewai import Crew, Task, Process
from langchain_openai import ChatOpenAI
from app.crew.config_loader import get_tenant_config
from app.crew.memory import get_memory
from app.utils.horario import esta_dentro_do_horario
from app.agents.intention_agent import build_intention_agent
from app.agents.vector_agents import build_rules_agent, build_support_agent
from app.agents.mcp_agent import build_mcp_agent
from app.agents.response_agent import build_response_agent

def build_crew(account_id, pergunta):
    """
    Cria uma crew completa para processar a pergunta do cliente.

    Args:
        account_id: ID da conta do tenant
        pergunta: Pergunta do cliente

    Returns:
        Crew configurada
    """
    # Carregar configuraÃ§Ã£o do tenant
    config = get_tenant_config(account_id)

    # Obter memÃ³ria do tenant
    memory = get_memory(account_id)

    # Configurar LLM
    llm = ChatOpenAI(model="gpt-4o-mini", temperature=0.3)

    # Criar agentes
    intention_agent = build_intention_agent(config)
    rules_agent = build_rules_agent(account_id)
    support_agent = build_support_agent(account_id)
    mcp_agent = build_mcp_agent(account_id, config)
    response_agent = build_response_agent(config)

    # Criar tarefas
    intention_task = Task(
        description=f"Analise a seguinte pergunta do cliente e identifique a intenÃ§Ã£o principal: '{pergunta}'",
        agent=intention_agent
    )

    rules_task = Task(
        description=f"Busque regras de negÃ³cio relevantes para a pergunta: '{pergunta}'",
        agent=rules_agent,
        async_execution=True
    )

    support_task = Task(
        description=f"Busque documentos de suporte relevantes para a pergunta: '{pergunta}'",
        agent=support_agent,
        async_execution=True
    )

    mcp_task = Task(
        description=f"Execute aÃ§Ãµes no sistema Odoo se necessÃ¡rio para responder: '{pergunta}'",
        agent=mcp_agent,
        async_execution=True
    )

    response_task = Task(
        description="Formule uma resposta final clara, cordial e personalizada para o cliente",
        agent=response_agent,
        context=[
            {"role": "system", "content": f"InformaÃ§Ãµes institucionais: {config.get('institucional', {})}"}
        ],
        depends_on=[intention_task, rules_task, support_task, mcp_task]
    )

    # Criar crew
    return Crew(
        agents=[intention_agent, rules_agent, support_agent, mcp_agent, response_agent],
        tasks=[intention_task, rules_task, support_task, mcp_task, response_task],
        process=Process.parallel,
        memory=memory,
        verbose=True,
        cache=True
    )
```

### 3.8 API FastAPI

```python
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from app.crew.crew_factory import build_crew
from app.crew.config_loader import get_tenant_config
from app.utils.horario import esta_dentro_do_horario

app = FastAPI()

class AtendimentoRequest(BaseModel):
    account_id: str
    pergunta: str

@app.post("/atendimento")
async def atendimento(request: AtendimentoRequest):
    """
    Endpoint para processar perguntas de clientes.

    Args:
        request: RequisiÃ§Ã£o contendo account_id e pergunta

    Returns:
        Resposta da crew
    """
    # Carregar configuraÃ§Ã£o do tenant
    config = get_tenant_config(request.account_id)

    # Verificar horÃ¡rio de atendimento
    if not esta_dentro_do_horario(config):
        atender_fora = config["atendimento"]["regras"].get("atender_fora_do_horario", False)

        if not atender_fora:
            return {
                "resposta": f"{config['estilo']['saudacao']} Estamos fora do horÃ¡rio de atendimento. "
                           f"Nosso horÃ¡rio Ã© {config['atendimento']['horarios']['horario']}. "
                           f"{config['estilo']['assinatura']}"
            }

    # Criar e executar crew
    try:
        crew = build_crew(request.account_id, request.pergunta)
        result = crew.kickoff()

        return {"resposta": result}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erro ao processar pergunta: {str(e)}")
```

## 4. Plano de ImplementaÃ§Ã£o

### 4.1 Fase 1: PreparaÃ§Ã£o

1. **Configurar ambiente de desenvolvimento**
   - Instalar dependÃªncias
   - Configurar variÃ¡veis de ambiente
   - Configurar Redis e Qdrant

2. **Criar estrutura de diretÃ³rios**
   - Seguir a estrutura proposta
   - Criar arquivos iniciais

3. **Implementar carregador de configuraÃ§Ã£o**
   - Implementar `config_loader.py`
   - Criar arquivos YAML de exemplo

### 4.2 Fase 2: Componentes BÃ¡sicos

1. **Implementar ferramentas vetoriais**
   - Implementar `vector_tools.py`
   - Testar conexÃ£o com Qdrant

2. **Implementar ferramentas MCP**
   - Implementar `mcp_tools.py`
   - Testar conexÃ£o com Odoo

3. **Implementar memÃ³ria Redis**
   - Implementar `memory.py`
   - Testar isolamento entre tenants

4. **Implementar verificador de horÃ¡rio**
   - Implementar `horario.py`
   - Testar com diferentes configuraÃ§Ãµes

### 4.3 Fase 3: Agentes

1. **Implementar agente de intenÃ§Ã£o**
   - Implementar `intention_agent.py`
   - Testar classificaÃ§Ã£o de intenÃ§Ãµes

2. **Implementar agentes vetoriais**
   - Implementar `vector_agents.py`
   - Testar busca em coleÃ§Ãµes do Qdrant

3. **Implementar agente MCP**
   - Implementar `mcp_agent.py`
   - Testar integraÃ§Ã£o com Odoo

4. **Implementar agente de resposta**
   - Implementar `response_agent.py`
   - Testar formataÃ§Ã£o de respostas

### 4.4 Fase 4: IntegraÃ§Ã£o

1. **Implementar fÃ¡brica de crew**
   - Implementar `crew_factory.py`
   - Testar criaÃ§Ã£o de crew completa

2. **Implementar API FastAPI**
   - Implementar `main.py`
   - Testar endpoint de atendimento

3. **Implementar detector de handoff**
   - Implementar `handoff_detector.py`
   - Testar redirecionamento para humano

### 4.5 Fase 5: Testes e OtimizaÃ§Ã£o

1. **Testes de performance**
   - Medir tempo de resposta
   - Identificar gargalos

2. **Testes de isolamento**
   - Verificar isolamento entre tenants
   - Testar concorrÃªncia

3. **OtimizaÃ§Ãµes finais**
   - Ajustar parÃ¢metros
   - Implementar melhorias identificadas

## 5. MÃ©tricas de Sucesso

1. **Tempo de resposta**
   - Meta: < 3 segundos para 95% das requisiÃ§Ãµes
   - Monitorar latÃªncia de cada componente

2. **Isolamento entre tenants**
   - Zero vazamento de dados entre tenants
   - ConfiguraÃ§Ãµes isoladas por account_id

3. **Qualidade das respostas**
   - Respostas precisas e relevantes
   - PersonalizaÃ§Ã£o conforme configuraÃ§Ã£o do tenant

4. **Escalabilidade**
   - Suporte a mÃºltiplos tenants simultÃ¢neos
   - DegradaÃ§Ã£o graceful sob carga

## 6. EstratÃ©gias para OtimizaÃ§Ã£o de Agentes

### 6.1 Gerenciamento de Agentes em Conversas Fluidas

Um desafio importante em conversas fluidas Ã© que os clientes podem alternar entre diferentes tÃ³picos que exigem diferentes agentes. Existem vÃ¡rias estratÃ©gias para lidar com isso:

#### 6.1.1 PrÃ©-carregamento Inteligente

- **PrÃ©-carregamento Baseado em HistÃ³rico**: Analisar o histÃ³rico de conversas do cliente para prÃ©-carregar os agentes mais provÃ¡veis de serem necessÃ¡rios
- **PrÃ©-carregamento por DomÃ­nio**: Certos domÃ­nios de negÃ³cio tÃªm padrÃµes previsÃ­veis de consulta que podem informar quais agentes prÃ©-carregar

#### 6.1.2 Carregamento Adaptativo

- **Carregamento em Segundo Plano**: Enquanto o agente de intenÃ§Ã£o processa a consulta, iniciar o carregamento de outros agentes em segundo plano
- **Cache de Agentes**: Manter um cache LRU (Least Recently Used) de agentes carregados, removendo apenas os menos usados quando necessÃ¡rio

#### 6.1.3 EstratÃ©gias de Fallback

- **Agente Universal**: Manter um agente de fallback que pode lidar com consultas gerais enquanto agentes especializados sÃ£o carregados
- **Resposta em Duas Fases**: Fornecer uma resposta rÃ¡pida inicial seguida de uma resposta mais detalhada quando todos os agentes estiverem disponÃ­veis

#### 6.1.4 ImplementaÃ§Ã£o Recomendada

Para nossa implementaÃ§Ã£o inicial, recomendamos:

1. **Abordagem HÃ­brida**: Carregar o agente de intenÃ§Ã£o e o agente de resposta sempre, e carregar os demais agentes conforme necessÃ¡rio
2. **Cache de SessÃ£o**: Manter agentes carregados durante toda a sessÃ£o de conversa
3. **PrÃ©-carregamento Baseado em IntenÃ§Ã£o**: Usar a primeira detecÃ§Ã£o de intenÃ§Ã£o para carregar agentes relacionados
4. **Monitoramento de Performance**: Registrar mÃ©tricas de tempo de carregamento e uso de agentes para otimizaÃ§Ã£o contÃ­nua

```python
# Exemplo de implementaÃ§Ã£o de cache de agentes
class AgentCache:
    def __init__(self, max_size=10):
        self.cache = {}
        self.max_size = max_size
        self.usage_count = {}

    def get(self, agent_type, account_id):
        key = f"{agent_type}:{account_id}"
        if key in self.cache:
            self.usage_count[key] += 1
            return self.cache[key]
        return None

    def put(self, agent_type, account_id, agent):
        key = f"{agent_type}:{account_id}"
        if len(self.cache) >= self.max_size and key not in self.cache:
            # Remover o agente menos usado
            least_used = min(self.usage_count.items(), key=lambda x: x[1])[0]
            del self.cache[least_used]
            del self.usage_count[least_used]

        self.cache[key] = agent
        self.usage_count[key] = 1
```

## 7. PrÃ³ximos Passos

1. **ImplementaÃ§Ã£o de dashboard de monitoramento**
   - VisualizaÃ§Ã£o de mÃ©tricas em tempo real
   - Alertas para problemas de performance

2. **ExpansÃ£o de ferramentas MCP**
   - Adicionar mais integraÃ§Ãµes com Odoo
   - Implementar operaÃ§Ãµes mais complexas

3. **Melhorias na detecÃ§Ã£o de intenÃ§Ã£o**
   - Treinamento especÃ­fico por domÃ­nio
   - Suporte a mÃºltiplos idiomas

4. **IntegraÃ§Ã£o com sistemas de feedback**
   - Coleta de feedback do cliente
   - Melhoria contÃ­nua baseada em feedback

5. **OtimizaÃ§Ã£o do gerenciamento de agentes**
   - Implementar cache de agentes
   - Desenvolver estratÃ©gias de prÃ©-carregamento
   - Testar diferentes configuraÃ§Ãµes para conversas fluidas

---

Este plano de implementaÃ§Ã£o fornece um roteiro detalhado para a criaÃ§Ã£o da nova arquitetura da CrewAI Multi-Tenant, otimizada para baixa latÃªncia, isolamento entre tenants e escalabilidade.
